---
layout: post
title: OSI 7 Layers
date: 2019-10-25
categories: Computer and Netrowk
tags: 
  - OSI
  - Network 
---

# 概述

我们每天都在用手机或者电脑等电子设备浏览网页，收发邮件。有没有想过为什么你在浏览器里面输入一个网址，就能打开一个页面？为什么你写了一封电子邮件，点击发送，对方就能收到这封邮件？下面就来总结一下最近学习的知识。

# 七层模型

网络模型分为七层，从下到上分别是：**物理层**，**链路层**，**网络层**，**传输层**，**会话层**，**表示层**和**应用层**。下层服务于上层，上层依赖于下层。

![七层模型](/assets/img/article-img/Computer%20and%20Network/OSI/OSI%207%20layers.jpg)

#### 物理层

两台机器之间要能收发数据，首先，必须得把他们给连起来。物理层就是负责把机器之间用光纤，电缆，网线或者wifi等“连起来”这件事的。设备之间有了物理联结之后，就可以传递电信号了。物理层规范了两台计算机之间的信号传输协议，通过数模转换和模数转换，使得数据能以bit的形式传输（也就是我们理解的二进制0和1的形式）。从无到有，物理层使得数据传输变为可能。

![物理层](/assets/img/article-img/Computer%20and%20Network/OSI/OSI%20physical.jpg)

#### 链路层

现在设备之间可以通过比特流来传递数据了，但是如果希望把数据发送到指定机器，就必须给每台机器编个号，或者给他们起个不同的名字，这就是MAC地址。计算机通过网卡联网，每张网卡在出厂时就会设置一个48位的序列，即MAC地址，全球唯一。所以计算机A要往计算机B传送数据，必须得知道B的MAC地址是多少。

![MAC 地址](/assets/img/article-img/Computer%20and%20Network/OSI/mac.jpg)

另外一个问题就是，比特流的传送，其实是电信号的传送，过程中会出错。为此，链路层规定了bit传输以帧为单位，最多1500位。每帧的头尾会用一个特定的格式来标示起始，内容包含header和body，头包括目的地址，源地址，帧长度及校验序列等信息。目标机器收到帧数据之后，可以通过头信息进行校验，如果有出错，会要求目标重发此帧。通过链路层，数据实现了正确传输。

#### 网络层

事实上，链路层的作用范围十分有限，仅限于同一个子网内部。所以我们需要另外一套机制，使得数据能跨越网络进行传输，这时就轮到我们熟悉的ip协议登场了。ip协议也是包含header信息和body信息，头包括目标ip，源ip，版本信息及长度信息等等。依赖于链路层，他们全都会放到数据帧的body里面。

ip地址即是设备在网络上的标识，常用的是ip协议第四版ipv4，由四个8位的二进制数组成。除了ip地址，每台联网的设备还会配置三个重要参数：子网掩码，网关地址，DNS服务器地址。子网掩码也是由四个8位的二进制数组成，高n位是1，低位是0，和ip做逻辑与操做后，可以判断设备所属的子网，所以同一个子网下的机器，子网掩码都是相同的。网关是设备与外部信息传输的接口，当两台机器不属于同一个子网，数据会发到网关，然后通过目标ip路由找到对方子网络，对方网关会通过ARP协议（这里暂不涉及）根据ip得到目标机器的mac地址，这样两台机器通过网关，实现了牵手。DNS服务器，其实就是存了一个域名和ip的映射表。比如我们访问www.google.com，机器会先去DNS服务器去找这个域名对应的机器的ip地址是多少，然后才根据这个ip去跟目标机器进行信息交换。域名使得机器的地址更直观，也更容易记忆。

![IP 配置](/assets/img/article-img/Computer%20and%20Network/OSI/ip.jpg)

一般的，我们不需要手动配置这几个地址，而是通过DHCP协议（这里暂且也不涉及）自动获取局域网内可用的地址。通常我们熟知的路由器就是支持DHCP的服务器。

网络层实现了设备间跨子网的数据传输。

#### 传输层

通过网络层，两台设备之间就可以进行数据传输了。但是每台设备上都运行了多个程序，它怎么区分接收到的数据是属于哪一个程序的呢？所以设备上还需要一个参数，叫端口，来跟某一个网络进程绑定。端口是十六位二进制数，也就是0到65535之间的数字，比如http端口80，ssh端口22等。知道了机器的ip和端口，就可以给机器上的程序发请求了。建立在这个基础之上，最简单的就是UDP协议，即用户数据报协议。UDP协议也是包含header和body，头中包含了源端口和目的端口，以及长度等信息。数据通过UDP协议封装成报文，在设备之间单方向传输。

![UDP格式](/assets/img/article-img/Computer%20and%20Network/OSI/udp.jpg)

从UDP协议开始往上，都是比较面向应用了。但是UDP协议有一个大问题，设备A向设备B传递一个报文，A没法知道B到底有没有收到。这也可以理解，协议中只是规定了数据以报文的形式发送，而没规定其他，甚至对方设备有没有联网，我们都无从得知。所以UDP协议提供了面向程序的不可靠的数据报传输。

对于大多数情况而言，数据丢包是不被允许的。基于UDP之上，诞生了TCP协议。TCP协议会在设备之间建立连接，并且增加了确认机制。当设备A要与设备B进行通信之前，必须与B建立连接，这个过程就是著名的TCP三次握手，由此双方建立连接。正式通信过程中，当设备B收到设备A的报文之后，必须向A回复ACK表示报文已经收到，过程中如果B没有ACK或者B的ACK报文丢掉了，A会对这个报文进行重传，以保证数据的完整性。这里有一个滑动窗口的概念，窗口大小即A和B间同时传送的报文的数量，会根据带宽动态调整。在一定的窗口大小之下，A只有在收到B对之前报文的ACK之后，才会把新的报文发送给B。当数据传输完毕，两个设备需要断开连接，即TCP的四次挥手。

![TCP 3次握手4次挥手](/assets/img/article-img/Computer%20and%20Network/OSI/TCP%203%20way%20handshake%204%20way%20termination.jpg)

TCP协议是面向连接的，保证了数据在设备间能可靠的传输。但是相比于UDP，因为增加了连接的建立和关闭，报文的确认，所以传输效率会低很多。

#### 会话层

理论上，有了传输层，计算机之间就能可靠的通信了，再往高层的大多都是基于TCP的封装。会话层主要负责连接的创立，保持与关闭，以及一些验证工作，使得数据的传输有面向连接的易用接口。比如大型文件的传输，就需要会话层做连接的控制。

#### 表示层

经过前面五层，看似设备间的通信问题已经完全解决，其实不然。因为数据都是通过二进制格式传输，这与我们所能理解的数据之间需要编码与解码的过程。但是由于历史原因，设备之间的编码格式有可能是不同的，大家熟知的是ASCII编码，还有IBM的EBCDIC编码。所以数据传输的时候需要有一个通用的格式，表示层就负责做这个转换。同时对数据的压缩，加解密也都在这一层完成。

#### 应用层

应用层直接面向用户，根据不同的场景，有不同的协议。比如用于文件传输的FTP，用于邮件系统的SMTP，用于超文本传输的HTTP等。

# 总结

OSI七层模型，完成了两个独立设备之间的信息交换，使得你可以在浏览器输入一个网址，然后网页上就呈现出来一个复杂的页面。互联网的一切通信，都是建立在这七层模型之上的。

