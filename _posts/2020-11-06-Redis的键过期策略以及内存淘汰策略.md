---
layout: post
title: Redis的键过期策略以及内存淘汰策略
date: 2020-11-06
categories:
  - Handbook
tags:
  - Redis
---

# Redis
**Redis**是高性能的基于内存的`NoSQL`数据库。因为内存是比较宝贵的资源，无法无限制使用，所以**Redis**提供了：
1. **键过期策略**来防止内存饱和。
2. **内存淘汰策略**来使得内存饱和之后继续对外提供服务。

# 内存过期策略

## expire命令
**Redis**提供了`expire`命令来给一个键(key)设置过期时间：
~~~sh
redis> SET foo "bar"
"OK"
redis> EXPIRE foo 10
(integer) 1
redis> TTL foo
(integer) 10
~~~
类似`setex`命令，也可以对目标键设置过期时间，但它其实相当于`set`和`expire`两个命令的原子操作。
`expire`只能作用于**Redis**中的键，所以无法对`list`或者`set`中的元素设置过期时间。对某个键调用删除(delete)或者重写(override)的命令如`del`,`set`,`getset`之后，会清除键上的过期时间；调用`persist`命令也会清除键上的过期时间；而修改键内容的操作如`incr`,`hset`，则不会对键的过期时间产生影响。

## 键的过期原理
**Redis**键有两种过期方式：被动方式(passive way)和主动方式(active way)。

#### 被动删除
当某个设置了过期时间的键被访问时，如果发现它已经过期，**Redis**会直接将其删除并返回一个空值。

#### 主动删除
被动删除是一种惰性删除机制，它不会花很多时间在键的删除上，保证了**Redis**的高性能。但是如果键一直不被访问，将导致内存泄漏。所以**Redis**提供了主动删除的策略：**Redis**会定期地(默认每秒钟10次)在设置了过期时间的键的集合(expire set)中，随机选择一部分键，判断删除。具体步骤如下：
1. 在过期键集合中随机选择20个键
2. 将其中已经过期的键删除
3. 如果其中过期的键占比超过25%，则重复步骤1

以上步骤会在**Redis**的每个(16个)数据库中都执行一遍，并且每次执行都会限制在一定时间之内，防止占用过多时间影响**Redis**处理性能。
这是一种基于概率的折中方案，既可以防止扫描过多的过期键影响**Redis**的吞吐量，同时也保证了过期键不会占用太多的空间。

#### 过期数据的恢复及同步
**Redis**的过期策略只在主节点中执行，当某个键过期时，主节点会往其副本节点(replicas)发送一个`del`命令，由此删除副本节点上的数据，从而保证数据的一致性，同时，也会往**aof**文件中写入一个`del`命令。
在**Redis**从**aof**文件中恢复的过程中，如果发现某个键已过期，会直接将之删除。类似的，在生成**rdb**文件时，如果发现过期键，该键将不会被写入快照文件。

注意，键的过期时间是基于机器的**unix时间戳**的，所以必须要保证机器时间的稳定性。比如将某个键的过期时间设置为1分钟之后，同时将机器时间调快1分钟，那么这个键将立马被认为是过期的。

**Redis**过期策略的源码在[这里](https://github.com/redis/redis/blob/a92921da135e38eedd89138e15fe9fd1ffdd9b48/src/expire.c#L98)。

# 内存淘汰策略
即使有了**键过期策略**，我们还是会不可避免地遇到内存不够的情况(已使用内存大于指定的`maxmemory`)。为了使**Redis**能继续工作(添加数据)，它会触发**内存淘汰策略**，来清除部分已存在的数据。

## Redis4.0之前的内存淘汰策略
内存淘汰策略可以用`maxmemory-policy`来指定，在**Redis4.0**之前提供了以下方式：
- noeviction: 不淘汰内存，当有**Redis**收到新的**写入**命令时，直接返回错误(查询以及`del`等命令除外)
- allkeys-lru: 在所有的键上，应用**LRU**(less recently used)策略，即淘汰最近最少使用的键
- volatile-lru: 在设置了过期时间的键上，应用**LRU**策略，如果过期键集为空，则和**noeviction**策略一样
- allkeys-random: 随机淘汰一部分键
- volatile-random: 随机淘汰设置了过期时间的键，如果过期键集为空，则和**noeviction**策略一样
- volatile-ttl: 在设置了过期时间的键集中，尽量淘汰**TTL**较小的键，即尽量淘汰即将过期的键，如果过期键集为空，则和**noeviction**策略一样

当客户端发送一条新的插入命令时，**Redis**通过检查发现当前内存占用超过了`maxmemory`，它将调用设置好的内存淘汰策略以腾出一部分内存空间，用来执行新的命令。

## LRU算法
精确的**LRU**算法将耗费较多的内存，所以**Redis**采用了一种近似的**LRU**算法：从集合中进行采样，并淘汰样本中最老的数据。可以通过`maxmemory-samples`(默认5)调整抽样的样本数量来控制**LRU**算法的精度。

下面是**Redis**中`Object`的定义：
~~~c
typedef struct redisObject {
    unsigned type:4;
    unsigned encoding:4;
    unsigned lru:LRU_BITS;
    int refcount;
    void *ptr;
} robj;
~~~
其中`lru`就是用来记录键的**LRU**时间的字段。算法就是对比这个字段的值来淘汰样本中老的数据的。

以下图片来自**Redis**官网，是理论**LRU**，**Redis2.8 LRU 5samples**，**Redis3.0 LRU 5samples**和**Redis3.0 LRU 10samples**的一个对比，可以看到**Redis3.0 LRU 10samples**已经很接近理论精度了。
![LRU Comparison](/src/img/article-img/Handbook/redis%20expire/lru_comparison.png)
 
## LFU策略

如果有一个键很少会被访问，但是恰巧最近被访问了，根据**LRU**策略，它是不会被清除的。所以**LRU**并不能非常确切地描述键的冷热。为此，从**4.0**版本开始，**Redis**提供了一种新的算法：**LFU**(Least Frequently Used)。在这种模式下，**Redis**会记录键的访问频率，访问频率越低，越有可能被清除。

**LFU**同样可以分别针对`allkeys`和`volatile`：
- volatile-lfu: 在设置了过期时间的键上，应用**LFU**策略.
- allkeys-lfu: 在所有键上，应用**LRU**策略，如果过期键集为空，则和**noeviction**策略一样.

**LFU**算法利用了一个计数器(probabilistic counter)，用来记录键被访问的频率：当键被访问，计数器会递增；每隔一定的周期，计数器会递减。其实这个计数器，依然存储在`redisObject`的`lru`字段中，它记录了*最近一次计数器递减的时间*和*计数器的值*两个信息。可以想到，有两个维度可以影响到计数器：
1. 计数器递减的周期：周期性递减可以保证计数器的时效性，并且保证值短期内不会无限制增长超过最大长度。
2. 计数器递增的速度：事实上**Redis**只给**访问计数**提供了8位(范围0-255)的存储空间，所以必须要控制计数器的递增速度来发挥每一位的效用。

对应地，**Redis**为这两个维度分别提供了`lfu-log-factor`(默认值10)和`lfu-decay-time`(默认值1)两个参数来调整算法的精度。默认值是基于实验的结果，即：约*100万次*请求之后，计数器达到最大值；每隔*1分钟*，计数器递减一次。`lfu-decay-time`很好理解。对于`lfu-log-factor`，可以参照下表：
| factor | 100 hits   | 1000 hits  | 100K hits  | 1M hits    | 10M hits   |
|:------:|:----------:|:----------:|:----------:|:----------:|:----------:|
| 0      | 104        | 255        | 255        | 255        | 255        |
| 1      | 18         | 49         | 255        | 255        | 255        |
| 10     | 10         | 18         | 142        | 255        | 255        |
| 100    | 8          | 11         | 49         | 143        | 255        |
前面已经介绍过，计数器的范围是0-255之间(8bit存储)，从表中可以看到，随着访问次数变大，计数器增长会变慢；当`lfu-log-factor`的值设的越小，计数器越快达到最大值255。所以，其实这个参数是用来控制*高访问频率*与*低访问频率*情况下算法的精度的。

# 总结
作为内存数据库，内存资源对于**Redis**来说是很宝贵的。**Redis**采用了**访问删除**与**定期删除**两种方式来处理过期(expired)数据；当应用内存达到`maxmemory`时，**Redis**会启用内存淘汰策略，最常用的有两种算法：最近最少使用(LRU)和最低频率访问(LFU)。

# 参考
[how redis expires keys](https://redis.io/commands/expire#how-redis-expires-keys)     
[Using Redis as an LRU cache](https://redis.io/topics/lru-cache)